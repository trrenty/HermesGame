damageHeadsUp=Ai grijă! [GOLD]Țepii[WHITE] dinaintea ta, cât și [GOLD]inamicii[WHITE] pe care-i vei întâlni te vor [GOLD]răni[WHITE]! Încearcă să nu-i atingi!
interact=Apasă [GOLD]{0} pentru a interacționa!
introInfo=Salutări, aventurierule! De aici începe aventura ta și a lui Hermes! Ajută-l să scape din adâncurile infernului și, între timp, învață despre minunile programării concurente în Java!
loading=Încărcare...
npc0dialogue0=Salutări, prietene. Arăți dubios de cărnos pentru unul de-al nostru.  
npc0dialogue1=Poate-ți va plăcea mai mult mai sus. Din păcate, ieșirea e blocată.
npc0dialogue2=Aș putea sa te ajut, dar trebuie să-mi găsesc pălăria mai întâi, nu pot ieși în lume fără sa arăt bine!
newTask=[GOLD]Ai un nou obiectiv!
findExit=Găsește o metodă de a elibera ieșirea!
helpTheLoon=Găsește pălăria Nebunaticului!
pickUp=Apasă [GOLD]{0} pentru a colecta!
newItem=Ai găsit un nou item!
npc0dialogue3=Mi-ai găsit pălăria! Mulțumesc, prietene! Ne vedem la ieșire, dacă vei vrea sa ieși vreodată!
taskDone=Ai finalizat o sarcină!
reset=Resetează {0}?
boulder=bolovanul
theThing=obiectul
npc1dialogue0=Ne-ai salvat! Îți mulțumim!
npc1dialogue1=Îți suntem îndatorați! Dacă te putem ajuta în vreun fel, anunță-ne!
npc1dialogue2=Vrei să muți bolovanul ăla? Sigur. Ne vedem acolo!
npc2dialogue0=Ajutor, vă rog! Mi-e frică!
npc2dialogue2=Sunt salvat! Îți mulțumesc!
npc2dialogue3=Bătăușul ăla n-a să mă mai deranjeze! Pentru că-i mort, căcatul...mort MORT! 
npc2dialogue1=Cineva, va rog, ajutați-mă..
npc2dialogue4=Sigur, te pot ajută să scapi! Ne vedem acolo!
enemyHeadsUp=Ai grijă! Inamici te așteaptă înainte!
npc0dialogue4=Ai ajuns în sfârșit? Pare că ai adus ajutoare! La semnalul tău, împingem!
ready=Pregătit?
npc0dialogue5=E prea mare chetroiul. Ne mai trebuie tovarăși!
npc0dialogue6=Haida!
locks1=În acest exemplu vom folosi 3 lacăte. Unul pentru Hermes, unul pentru orice alt obstacol care poate ședea pe placă și încă unul pentru a reprezenta starea ușii. închisă/deschisă\
\nReentrantLock [VAR]sharedLock[NR];\
\nReentrantLock [VAR]playerLock[NR];\
\nReentrantLock [VAR]rockLock[NR];
threadCountDown=[GREEN]"CountDown" a fost apelată de {0}
threadAwait=[GREEN]{0} așteaptă!
threadBarrierUp=Barieră ridicată!
threadLockTried={0} a încercat lacătul!
threadLockAcquired={0} a obținut lacătul!
locks0=Folosind următorul dispozitiv, voi exemplifica cum putem asigura apartenența unui obiect la un singur proprietar.
locks2=În momentul în care Hermes sau o piatră se pun pe placă, lacătul specific obiectului (Hermes/piatră) este închuiat de către Threadul principal.\
\n[VAR]playerLock[NR].lock(); / [VAR]rockLock[NR].lock();\
\n[WH]Acest fapt va lăsa obiectele să treacă mai departe și să încerce să pună mâna pe lacătul ușii.\
\n[KW]if [NR](![VAR]ownLock[NR].tryLock()) \
\n[VAR]sharedLock.[NR]lockInterruptibly();\
\n[WH]Dacă lacătul ușii aparține oricărui Thread, atunci ușa se va deschide
respawn=Apasă orice buton pentru a reînvia
locks3=Dacă un obiect încearcă lacătul ușii dar acesta este deținut deja, obiectul va aștepta până când \
deținătorul lacătului va pleca de pe placă sau până când obiectul va fi intrerupt de către un semnal\
trimis de către Threadul principal. \n\
[VAR]objectLock[NR].unlock(); \n\
[KW]if [NR]([VAR]sharedLock[NR].hasQueuedThread([VAR]objectThread[NR])) \n\
[VAR]objectLock[NR].interrupt(); \n\
                
threadCountDown0=CountDownLatch este o unealtă care permite unui developer să facă un set de Threaduri să aștepte la o \
barieră comună care se va ridica când un număr predefinit de Thread-uri vor aștepta la ea. Acesta se \
folosește în general la sincronizarea pornirii unui număr de threduri sau pentru a face fiecare thread \
să aștepte execuția tuturor celorlalte.
threadCountDown1=În continuare vom explora prima situație în care un număr dat de threaduri se vor aștepta între ele \
înainte ca acestea să-și înceapă execuția. Funcționalitatea acestuia va fi demonstrată cu ajutorul \
personajelor - Nebunaticul, Ei, Micuțul, Hermes - fiecare reprezentând câte un thread.
threadCountDown2=Fiecare caracter/thread este ocupat cu propriile treburi. Vor ajunge, eventual, la barieră și-i vor astepta \
pe ceilalți. Tu trebuie să-i scoți din rutină pentru ca aceștia să poată continua către barieră. Când un \
thread va aștepta, vei fi notificat în colțul din dreapta-jos.
grump0=Ugh..mori, ajungi în iad și nici măcar aici nu scap de căcați enervanți ca tine...nu vezi că-s ocupat? \
Du-te enervează pe altcineva!
grump1=Ești așa de prost cât nici n-ai înțeles ce ți-am zis?! Dispari!
grump2=Bine. Poate am fost prea răutăcios. N-ai vrea să consideri să te oprești din a exista în acest loc?
grump3=Cu siguranță ești la fel de prost pe cât arăți...
grump4=...
grump5=......
grump6=*Dacă-l ignor, cu siguranță va pleca*
grump7=Te rog, DOAMNE! Ascultă-mi rugăciunea!! Ia-l pe ăsta de aici!!!
grump8=Omule...
grump9=Te voi da o poțiune de viață ca sa o stergi de aici! Ce zici?
yesOrNo=Apasă [GOLD]Y[WH] pentru DA sau [GOLD]N [WH]pentru NU
fuckYou=DU-TE DRACULUI!
threadPhaser=[KW]public void [FN]run[NR]() {{\n\
[KW]while [NR](![VAR]phaser[NR].isTerminated()) {{\n\
[VAR]phaser[NR].awaitAdvance([VAR]phaser[NR].getPhase());\n\
[KW]for [NR](Runnable runnable : [KW]new [NR]Array.ArrayIterator<>([VAR]runnables[NR])) {{\n\
[VAR]runnable[NR].run();\n\
}\n\
}\n\
}
charon0=Of..Încă unu..
charon1=Dă-mi monedele și hai să plecăm..
charon2=Nu-i ai? N-ai bani, nu treci. De ce? Asta e legea, de aia.
charon3=Poate vei găsi ceva în ruinele de deasupra. Grăbește-te! N-am timp toată ziua!
charon4=De ce mai pierzi vremea? Dispari!
charon5=Doar unul? Vrei sa te duc jumate de drum și să te arunc în râu?
charon6=În sfârșit! Dă-mii și s-o ștergem.
taskCoinsTimer=Găsește monedele înainte să expire timpul! {0}:{1}
bully0=De ce mă deranjezi din nou? Nu poate un domn să-și trateze rănile în pace?
bully1=Îmi cer scuze că te-am bruscat. Nu am intenționat asta. Cearta mea cu IDIOTUL ĂLA...adică...cu acel domn, m-a bruiat.
bully2=Îmi pare rău. Totuși, acum am fantezii  violente cu tine pentru că ai intervenit adineauri.
bully3=Mă rog pentru sănătatea ta în cazul în care nu prezinti un motiv bun pentru a evita însângerarea acestei dupăamiezi.
bully4="Uite motivul" (dă-i bănuțul) - [GOLD]1[WH]\n\
"Scuze :(" - [GOLD]2[WH]\n\
"Dă-te naibii:" - [GOLD]3
bully5=Ah...un semn de binevoință. Fie ca drumurile noastre să se intersecteze din nou în viitor.
bully6=Înteleg. Să ai o zi bună.
bully7=Deci ai ales...MOARTEA.
locksGeneral0=Cum fiecare joc își are logica updatară într-o buclă, avem nevoie ca și Thread-urile să se updateze în același mod.\
Pentru a atinge acest scop și să evităm looping care nu-și are rostul, ne putem folosi de utilitatea [GOLD]PHASER[WH].
locksGeneral1=Mai sus puteți observa logica din spatele fiecărui Thread folosit în acest joc. Fiecare instanță deține următoarele obiecte:\n\
[NR]Phaser [VAR]phaser \n\
[NR]Array<Runnable> [VAR]runnables \n\
[WH]Așa ne putem asigura că logica din Threaduri, care poate fi extinsă prin Runnables adiționale,\
 se repetă numai cand avem nevoie. Și atunci când avem nevoie, apelăm din threadul main\n\
 [VAR]phaser[NR].arriveAndAwaitAdvance();\
 \
threadLockRock=
threadLockRock0=În spatele pietrei, dar și a jucătorului, avem un thread care se va folosi de un Runnable asociat. După cum am mai menționat, acesta va \\\
avea nevoie de aces la două lacăte. Unul care-l va reprezenta pe el, iar cel de al doilea, obiectul împărțit
threadLockRock1=Cele două threaduri vor fi activate de către phaser de fiecare dată când caracterul sau piatra vor atinge placa în joc. Lacătele asociate lor\
vor fi închuiate în momentul atingerii. În continuare, ar trebui sa poată obține lacătul distribuit.
threadLockRock2=Când vor încerca să obțină lacătul distribuit, vor încerca în mod intreruptibil. Acest lucru se îmtâmplă deoarece, în momentul în care\
obiectul nu va mai atinge placa, acesta va fi înterrupt. Dacă celălalt obiect va pleca, obiectul nostru va obține lacătul cu prima ocazie.
threadLockCode=public void run() {{\n\
|    if (ownLock.tryLock()) {{\n\
|    |    if (sharedLock.isHeldByCurrentThread()) {{\n\
|    |    |    sharedLock.unlock();\n\
|    |    }\n\
|    |    ownLock.unlock();\n\
|    } else {{\n\
|        try {{\n\
|            if (!sharedLock.isHeldByCurrentThread()) {{\n\
|            |    sharedLock.lockInterruptibly();\n\
|            }\n\
|        } catch (InterruptedException ignored) {{\n\
|        }\n\
|    }\n\
}
threadCountDownMini0=Acum că l-ai ajutat pe Mini, acesta este gata să te ajute. Acesta a apelat metoda [GOLD]countdown [WH]care presupune faptul că și-a terminat\
treburile, și acum [GOLD]așteaptă [WH]toate celelalte fantome/threaduri să fie și ele gata.

